{"version":3,"file":"main.cjs.js","sources":["../src/helpers/flatten/flatten.js","../src/ArrayMatrix/ArrayMatrix.js"],"sourcesContent":["/**\n * @function flatten\n * @description flattens an array of arrays into a single array.\n *\n * @param {Array} array : array to flatten.\n *\n * @returns {Array} flattened array.\n */\nconst flatten = (array) => {\n  if (!(array instanceof Array)) return array;\n  return array.reduce((a, b) => {\n    if (b instanceof Array) a.push.apply(a, flatten(b)); // eslint-disable-line prefer-spread\n    else if (!b) a.push(null);\n    else a.push(b);\n    return a;\n  }, []);\n};\n\nexport default flatten;\n","import { flatten } from '../helpers';\n/**\n * @class ArrayMatrix\n * @description An n-level data object that creates an array\n * matrix from JavaScript Objects based on orders provided.\n *\n * @requires flatten\n *\n * @exports ArrayMatrix\n */\nconst ArrayMatrix = function Tensor() {\n  /**\n   * @var props\n   * @description array matrix properties\n   * @access private\n   */\n  const props = {\n    dataset: null,\n    order: 0,\n    orders: [],\n  };\n\n  /**\n   * @var axes\n   * @description Stores the axes of the n-order matrix, and\n   * corresponding index for String valued index labels.\n   * @access private\n   *\n   * NOTE: axes is the plural of axis.\n   */\n  const axes = {};\n\n  /**\n   * @var matrix\n   * @description n-order matrix for storing the data set.\n   * @access private\n   */\n  const matrix = [];\n\n  /**\n   * @constructor\n   * @param {Object}\n   * @prop {Array} data : data set to map and store\n   * @prop {Array} orders : names of the orders making up the array matrix\n   */\n  function constructor({ data, orders }) {\n    /*\n      Store properties in the tensor object.\n    */\n    props.order = orders.length;\n    props.orders = orders;\n    props.dataset = data;\n\n    /*\n      For each order, create a key-value pair of\n      the order's name and an empty array in the\n      indices.\n    */\n    (() => {\n      let o = orders.length;\n      while (o--) { // eslint-disable-line no-plusplus\n        axes[orders[o]] = {};\n      }\n    })();\n\n    /*\n      Loop through each item in your dataset,\n      dive into the matrix, and place the item\n      at the correct vertices.\n    */\n    data.forEach((item) => {\n      let pointer = 0;\n      let plane = matrix;\n\n      while (pointer < props.order) {\n        const order = orders[pointer];\n        const index = getAxisPoint(order, item[order], plane); // eslint-disable-line\n        plane = plane[index];\n\n        pointer += 1;\n      }\n\n      plane.push(item);\n    });\n\n    return this;\n  }\n\n  /**\n   * @function getAxisPoint\n   * @description Checks to see if a point exists on the\n   * given axis.\n   *\n   * If it does not exist, it creates the point on the axis and and returns\n   * the index of the new point. The new axis/point assigned\n   * is based off the length of the existing axis's keys to ensure\n   * it is always forced to the very last index in the list.\n   *\n   * If it does exist, it returns the index of the existing point.\n   * @access private\n   *\n   * @param {String} axis : name of the axis\n   * @param {String} point : name for a point on the axis\n   * @param {Array} plane : dimension or plane of the array matrix\n   *\n   * @returns {Integer} index of string label\n   */\n  function getAxisPoint(axis, point, plane) {\n    const i = axes[axis];\n\n    if (typeof i[point] !== 'number') {\n      i[point] = Object.keys(i).length;\n    }\n\n    if (!(plane[i[point]] instanceof Array)) {\n      plane[i[point]] = []; // eslint-disable-line no-param-reassign\n    }\n\n    return i[point];\n  }\n\n  /**\n   * @function getTuple\n   * @description gets the tuple from named points on the axes.\n   * @access private\n   *\n   * @param {Object} points - key value pair of axis/point to get index for.\n   *\n   * @returns {Array} array equivalent of tuple with null as missing point values.\n   */\n  function getTuple(points) {\n    const keys = Object.keys(points);\n    const tuple = new Array(props.order).fill(null);\n\n    for (let i = 0, l = keys.length; i < l; i++) { // eslint-disable-line no-plusplus\n      const key = keys[i];\n      const mIndex = props.orders.indexOf(key);\n\n      if (mIndex === -1) {\n        throw new Error(`Tuple Error: Axis ${key} not found in available axes: ${props.orders.join(', ')}.`);\n      }\n\n      if (typeof points[key] === 'string') {\n        tuple[mIndex] = axes[key][points[key]];\n        if (typeof tuple[mIndex] === 'undefined') {\n          throw new Error(`Tuple Error: Point ${[points[key]]} not found in axis ${key} points: ${Object.keys(axes[key]).join(', ')}`);\n        }\n        continue; // eslint-disable-line no-continue\n      }\n\n      if (typeof points[key] === 'number') {\n        tuple[mIndex] = points[key];\n        continue; // eslint-disable-line no-continue\n      }\n\n      throw new Error(`Tuple Error: ${points[key]} for axis ${key} is not a valid string or integer.`);\n    }\n\n    return tuple;\n  }\n\n  /**\n   * @function deadReckon\n   * @description recursive function that dives into the array matrix\n   * and returns an element or dimension from a set of points.\n   * @access private\n   *\n   * @param {Array} plane : dimension or plane to start.\n   * @param {Array} indices : list of indices to traverse.\n   *\n   * @returns {Any} the node at the end of the traversal\n   */\n  function deadReckon(plane, indices) {\n    if (!indices || !indices.length) return plane;\n\n    return deadReckon(plane[indices.shift()], indices);\n  }\n\n  /**\n   * @function getAxes\n   * @description returns all axes and each axis' points\n   * @access public\n   *\n   * @returns {Object} axes' names with arrays of points\n   */\n  this.getAxes = function getAxes() {\n    return Object.keys(axes).reduce((accumulator, current) =>\n      Object.assign({}, accumulator, { [current]: Object.keys(axes[current]) })\n    , {});\n  };\n\n  /**\n   * @function getAxisPoints\n   * @description returns all points for a given axis.\n   * @access public\n   *\n   * @param {String} axis : name of axis.\n   *\n   * @returns {Array} Array of all an axis's named points.\n   */\n  this.getAxisPoints = function getAxisPoints(axis) {\n    if (!axes[axis]) return null;\n\n    return Object.keys(axes[axis]);\n  };\n\n  /**\n   * @function getDimension\n   * @description gets a dimension of the matrix array based on\n   * named points provided.\n   *\n   * The dimension is the plane of values existing by connecting\n   * n vertices, where n is 1 less than the total number of orders.\n   * @access public\n   *\n   * @param {Object} points : key-value pairs of axis and named points on the axis.\n   *\n   * @returns {Array} array of entries in the plane.\n   */\n  this.getDimension = function getDimension(points) {\n    if (!points || typeof points !== 'object') {\n      throw new Error('Dimension Error: Malformed points argument.');\n    }\n\n    const keys = Object.keys(points);\n\n    if (keys.length !== props.order - 1) {\n      throw new Error(`Dimension Error: ${keys.length} points provided for ${props.order} order matrix array. The number of points must be equal to n - 1, where n is the order or rank of the matrix array.`);\n    }\n\n    const coords = getTuple(points);\n\n    const variableIndex = coords.indexOf(null);\n\n    const entries = (() => {\n      if (variableIndex === 0) {\n        coords.splice(0, 1);\n\n        return matrix.map(aIndex => deadReckon(aIndex, [].concat(coords)));\n      }\n\n      return deadReckon(matrix, coords.slice(0, variableIndex))\n              .map(array => deadReckon(array, coords.slice(variableIndex + 1)));\n    })();\n\n    return flatten(entries);\n  };\n\n  /**\n   * @function getEntry\n   * @description returns the entry in the matrix array at the points provided.\n   * @access public\n   *\n   * @param {Object} points : key-value pairs of named points on axes.\n   *\n   * @returns {Object} entry at the set of points.\n   */\n  this.getEntry = function getEntry(points) {\n    const keys = Object.keys(points);\n\n    if (keys.length !== props.order) {\n      throw new Error(`Entry Error: ${keys.length} points provided for ${props.order} order matrix array. The number of points must be equal to n, where n is the order or rank of the matrix array.`);\n    }\n\n    const coords = getTuple(points);\n\n    let depth = 0;\n    let pointer = matrix;\n    while (depth < coords.length) {\n      if (pointer[coords[depth]]) {\n        pointer = pointer[coords[depth]];\n        depth += 1;\n        continue; // eslint-disable-line no-continue\n      }\n\n      return null;\n    }\n\n    return pointer[0];\n  };\n\n  /**\n   * @function debug\n   * @description returns the array matrix's data\n   * @access public\n   */\n  this.debug = function debug() {\n    return {\n      matrix,\n      axes,\n      props,\n    };\n  };\n\n  return constructor.apply(this, arguments); // eslint-disable-line prefer-rest-params\n};\n\nexport default ArrayMatrix;\n"],"names":["flatten","array","Array","reduce","a","b","push","apply","ArrayMatrix","props","axes","matrix","getTuple","points","keys","Object","tuple","order","fill","i","l","length","key","mIndex","orders","indexOf","Error","join","deadReckon","plane","indices","shift","getAxes","accumulator","current","babelHelpers.extends","getAxisPoints","axis","getDimension","coords","variableIndex","entries","splice","map","aIndex","concat","slice","getEntry","depth","pointer","debug","data","dataset","o","forEach","item","point","this","arguments"],"mappings":"aAQA,IAAMA,UAAU,SAAVA,EAAWC,UACTA,aAAiBC,MAChBD,EAAME,OAAO,SAACC,EAAGC,UAClBA,aAAaH,MAAOE,EAAEE,KAAKC,MAAMH,EAAGJ,EAAQK,IACtCA,EACLD,EAAEE,KAAKD,GADCD,EAAEE,KAAK,MAEbF,GACN,IANmCH,sgBCClCO,cAAc,eAMZC,EAAQ,SACH,WACF,SACC,IAWJC,EAAO,GAOPC,EAAS,YA6FNC,EAASC,WACVC,EAAOC,OAAOD,KAAKD,GACnBG,EAAQ,IAAId,MAAMO,EAAMQ,OAAOC,KAAK,MAEjCC,EAAI,EAAGC,EAAIN,EAAKO,OAAQF,EAAIC,EAAGD,IAAK,KACrCG,EAAMR,EAAKK,GACXI,EAASd,EAAMe,OAAOC,QAAQH,OAEpB,IAAZC,QACI,IAAIG,2BAA2BJ,mCAAoCb,EAAMe,OAAOG,KAAK,cAGlE,iBAAhBd,EAAOS,OAQS,iBAAhBT,EAAOS,SAKZ,IAAII,sBAAsBb,EAAOS,gBAAiBA,0CAJhDC,GAAUV,EAAOS,aARjBC,GAAUb,EAAKY,GAAKT,EAAOS,SACJ,IAAlBN,EAAMO,SACT,IAAIG,4BAA4B,CAACb,EAAOS,0BAA2BA,cAAeP,OAAOD,KAAKJ,EAAKY,IAAMK,KAAK,cAanHX,WAcAY,EAAWC,EAAOC,UACpBA,GAAYA,EAAQT,OAElBO,EAAWC,EAAMC,EAAQC,SAAUD,GAFFD,cAYrCG,QAAU,kBACNjB,OAAOD,KAAKJ,GAAMP,OAAO,SAAC8B,EAAaC,UAC5CC,SAAc,GAAIF,oBAAgBC,EAAUnB,OAAOD,KAAKJ,EAAKwB,OAC7D,UAYCE,cAAgB,SAAuBC,UACrC3B,EAAK2B,GAEHtB,OAAOD,KAAKJ,EAAK2B,IAFA,WAkBrBC,aAAe,SAAsBzB,OACnCA,GAA4B,qBAAXA,sBAAAA,UACd,IAAIa,MAAM,mDAGZZ,EAAOC,OAAOD,KAAKD,MAErBC,EAAKO,SAAWZ,EAAMQ,MAAQ,QAC1B,IAAIS,0BAA0BZ,EAAKO,+BAA8BZ,EAAMQ,iIAGzEsB,EAAS3B,EAASC,GAElB2B,EAAgBD,EAAOd,QAAQ,MAE/BgB,EACkB,IAAlBD,KACKE,OAAO,EAAG,GAEV/B,EAAOgC,IAAI,mBAAUf,EAAWgB,EAAQ,GAAGC,OAAON,OAGpDX,EAAWjB,EAAQ4B,EAAOO,MAAM,EAAGN,IACjCG,IAAI,mBAASf,EAAW3B,EAAOsC,EAAOO,MAAMN,EAAgB,aAGhExC,UAAQyC,SAYZM,SAAW,SAAkBlC,OAC1BC,EAAOC,OAAOD,KAAKD,MAErBC,EAAKO,SAAWZ,EAAMQ,YAClB,IAAIS,sBAAsBZ,EAAKO,+BAA8BZ,EAAMQ,iIAGrEsB,EAAS3B,EAASC,GAEpBmC,EAAQ,EACRC,EAAUtC,EACPqC,EAAQT,EAAOlB,QAAQ,KACxB4B,EAAQV,EAAOS,WAMZ,OALKC,EAAQV,EAAOS,OAChB,SAONC,EAAQ,SAQZC,MAAQ,iBACJ,2CAlPcC,IAAAA,KAAM3B,IAAAA,gBAIrBP,MAAQO,EAAOH,SACfG,OAASA,IACT4B,QAAUD,qBAQVE,EAAI7B,EAAOH,OACRgC,OACA7B,EAAO6B,IAAM,QASjBC,QAAQ,SAACC,WACRN,EAAU,EACVpB,EAAQlB,EAELsC,EAAUxC,EAAMQ,OAAO,KACtBA,EAAQO,EAAOyB,KAEbpB,GA8BQQ,EA/BWpB,EA+BLuC,EA/BYD,EAAKtC,GA+BVY,EA/BkBA,EAgC7CV,OAAAA,EAAAA,EAAIT,EAAK2B,GAES,iBAAblB,EAAEqC,OACTA,GAASzC,OAAOD,KAAKK,GAAGE,QAGtBQ,EAAMV,EAAEqC,cAAmBtD,UACzBiB,EAAEqC,IAAU,IAGbrC,EAAEqC,QAvCM,MA4BKnB,EAAMmB,EAAO3B,EAC3BV,IA1BEb,KAAKiD,KAGNE,MAiNUlD,MAAMkD,KAAMC"}