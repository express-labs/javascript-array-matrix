{"version":3,"file":"main.cjs.js","sources":["../src/helpers/flatten/flatten.js","../src/Tensor/Tensor.js"],"sourcesContent":["/**\n * @function flatten\n * @description flattens an array of arrays into a single array.\n *\n * @param {Array} array : array to flatten.\n *\n * @returns {Array} flattened array.\n */\nconst flatten = (array) => {\n  if (!(array instanceof Array)) return array;\n  return array.reduce((a, b) => {\n    if (b instanceof Array) a.push.apply(a, flatten(b)); // eslint-disable-line prefer-spread\n    else if (!b) a.push(null);\n    else a.push(b);\n    return a;\n  }, []);\n};\n\nexport default flatten;\n","import { flatten } from '../helpers';\n/**\n * @class Tensor\n * @description Tensor manager n-layer datasets\n *\n * @requires flatten\n *\n * @exports Tensor\n */\nconst Tensor = function Tensor() {\n  /**\n   * @var props\n   * @description tensor properties\n   * @access private\n   */\n  const props = {\n    order: 0,\n    orders: [],\n  };\n\n  /**\n   * @var indices\n   * @description Stores the indices of the n-order matrix, and\n   * corresponding index for String valued index labels.\n   * @access private\n   */\n  const indices = {};\n\n  /**\n   * @var matrix\n   * @description n-order matrix for storing the data set.\n   * @access private\n   */\n  const matrix = [];\n\n  /**\n   * @constructor\n   * @param {Object}\n   * @prop {Array} data : data set to map and store\n   * @prop {Array} mutators : any mutations to execute against the data set\n   * @prop {Array} orders : names of the orders making up the tensor\n   */\n  function constructor({ data, orders }) {\n    /*\n      Store properties in the tensor object.\n    */\n    props.order = orders.length;\n    props.orders = orders;\n\n    /*\n      For each order, create a key-value pair of\n      the order's name and an empty array in the\n      indices.\n    */\n    (() => {\n      let o = orders.length;\n      while (o--) { // eslint-disable-line no-plusplus\n        indices[orders[o]] = {};\n      }\n    })();\n\n    /*\n      Loop through each item in your dataset,\n      dive into the matrix, and place the item\n      at the correct vertices.\n    */\n    data.forEach((item) => {\n      let pointer = 0;\n      let array = matrix;\n\n      while (pointer < props.order) {\n        const order = orders[pointer];\n        const index = getIndex(order, item[order], array); // eslint-disable-line\n        array = array[index];\n\n        pointer += 1;\n      }\n\n      array.push(item);\n    });\n\n    return this;\n  }\n\n  /**\n   * @function getIndex\n   * @description Checks to see if a value exists in the\n   * indices.\n   *\n   * If it does not exist, it creates the value and and returns\n   * the index of the new value. The new index/value assigned\n   * is based off the length of the existing index's keys to ensure\n   * it is always forced to the very last index in the list.\n   *\n   * If it does exist, it returns the index of the existing value.\n   * @access private\n   *\n   * @param {String} index : label of the index\n   * @param {String} value : data item's value for the index\n   * @param {Array} array : dimensional array of matrix\n   *\n   * @returns {Integer} index of string label\n   */\n  function getIndex(index, value, array) {\n    const i = indices[index];\n\n    if (typeof i[value] !== 'number') {\n      i[value] = Object.keys(i).length;\n    }\n\n    if (!(array[i[value]] instanceof Array)) {\n      array[i[value]] = []; // eslint-disable-line no-param-reassign\n    }\n\n    return i[value];\n  }\n\n  /**\n   * @function getVertices\n   * @description gets the vertices from string values for a\n   * query.\n   * @access private\n   *\n   * @param {Array} keys - list of query keys\n   * @param {Object} vertices - key value pair of index/value to get vertices for.\n   *\n   * @returns {Array} vertices with null as missing vertex values.\n   */\n  function getVertices(keys, vertices) {\n    const vector = new Array(props.order).fill(null);\n    for (let i = 0, l = keys.length; i < l; i++) { // eslint-disable-line no-plusplus\n      const key = keys[i];\n      const mIndex = props.orders.indexOf(key);\n\n      if (mIndex === -1) {\n        throw new Error(`Vector Error: Index ${key} not found in available indices: ${props.orders.join(', ')}.`);\n      }\n\n      if (typeof vertices[key] === 'string') {\n        vector[mIndex] = indices[key][vertices[key]];\n        if (typeof vector[mIndex] === 'undefined') {\n          throw new Error(`Vector Error: Label ${[vertices[key]]} not found in index ${key} labels: ${Object.keys(indices[key]).join(', ')}`);\n        }\n        continue; // eslint-disable-line no-continue\n      }\n\n      if (typeof vertices[key] === 'number') {\n        vector[mIndex] = vertices[key];\n        continue; // eslint-disable-line no-continue\n      }\n\n      throw new Error(`Vector Error: Value ${vertices[key]} for index ${key} is not a valid string or integer.`);\n    }\n\n    return vector;\n  }\n\n  /**\n   * @function diveMatrix\n   * @description recursive function that dives deep into\n   * a matrix a returns data/dimension from a set of vertices.\n   * @access private\n   *\n   * @param {Array} array : dimension of the tensor.\n   * @param {Array} idx : list of vertices to traverse.\n   *\n   * @returns {Any} the node at the end of the traversal\n   */\n  function diveMatrix(array, idx) {\n    if (!idx || !idx.length) return array;\n\n    return diveMatrix(array[idx.shift()], idx);\n  }\n\n  /**\n   * @function getIndices\n   * @description returns all indices and labels\n   * @access public\n   *\n   * @returns {Object} indices keys with arrays of matrix labels\n   */\n  this.getIndices = function getIndices() {\n    const axes = {};\n\n    Object.keys(indices).forEach((index) => {\n      axes[index] = Object.keys(indices[index]);\n    });\n\n    return axes;\n  };\n\n  /**\n   * @function getIndexLabels\n   * @description returns all labels for a given index.\n   * @access public\n   *\n   * @param {String} index : index for labels to return.\n   *\n   * @returns {Array} Array of all an index's labels.\n   */\n  this.getIndexLabels = function getIndexLabels(index) {\n    if (!indices[index]) return null;\n\n    return Object.keys(indices[index]);\n  };\n\n  /**\n   * @function getVector\n   * @description gets a vector (slice) of the matrix based on\n   * vertices provided.\n   *\n   * The slice is the plane of values existing by connecting\n   * n vertices, where n is 1 less than the total number of orders.\n   * @access public\n   *\n   * @param {Object} vertices : key-value pairs of indices and values/index\n   *\n   * @returns {Array} array of values in the plane.\n   */\n  this.getVector = function getVector(vertices) {\n    if (!vertices || typeof vertices !== 'object') {\n      throw new Error('Vector Error: Malformed vertices provided.');\n    }\n\n    const keys = Object.keys(vertices);\n\n    if (keys.length !== props.order - 1) {\n      throw new Error(`Vector Error: ${keys.length} vertices provided for ${props.order} order tensor. The number of vertices must be equal to n - 1, where n is the order of the tensor.`);\n    }\n\n    const coords = getVertices(keys, vertices);\n\n    const variableIndex = coords.indexOf(null);\n\n    const scalars = (() => {\n      if (variableIndex === 0) {\n        coords.splice(0, 1);\n\n        return matrix.map(aIndex => diveMatrix(aIndex, [].concat(coords)));\n      }\n\n      return diveMatrix(matrix, coords.slice(0, variableIndex))\n              .map(array => diveMatrix(array, coords.slice(variableIndex + 1)));\n    })();\n\n    return flatten(scalars);\n  };\n\n  /**\n   * @function getScalar\n   * @description returns a value at a given set of vertices\n   * @access public\n   *\n   * @param {Object} vertices : key-value pairs of indices and values/index\n   *\n   * @returns {Any} value at the set of vertices.\n   */\n  this.getScalar = function getScalar(vertices) {\n    const keys = Object.keys(vertices);\n\n    if (keys.length !== props.order) {\n      throw new Error(`Scalar Error: ${keys.length} vertices provided for ${props.order} order tensor. The number of vertices must be equal to n, where n is the order of the tensor.`);\n    }\n\n    const coords = getVertices(keys, vertices);\n\n    let pointer = 0;\n    let array = matrix;\n    while (pointer < coords.length) {\n      if (array[coords[pointer]]) {\n        array = array[coords[pointer]];\n        pointer += 1;\n        continue; // eslint-disable-line no-continue\n      }\n\n      return null;\n    }\n\n    return array[0];\n  };\n\n  /**\n   * @function debug\n   * @description returns the tensors data\n   * @access public\n   */\n  this.debug = function debug() {\n    return {\n      matrix,\n      indices,\n      props,\n    };\n  };\n\n  return constructor.apply(this, arguments); // eslint-disable-line prefer-rest-params\n};\n\nexport default Tensor;\n"],"names":["flatten","array","Array","reduce","a","b","push","apply","Tensor","props","indices","matrix","getVertices","keys","vertices","vector","order","fill","i","l","length","key","mIndex","orders","indexOf","Error","join","Object","diveMatrix","idx","shift","getIndices","axes","forEach","index","getIndexLabels","getVector","coords","variableIndex","scalars","splice","map","aIndex","concat","slice","getScalar","pointer","debug","data","o","item","value","this","arguments"],"mappings":"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"}