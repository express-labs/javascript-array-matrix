{"version":3,"file":"main.es.js","sources":["../src/helpers/flatten/flatten.js","../src/ArrayMatrix/ArrayMatrix.js"],"sourcesContent":["/**\n * @function flatten\n * @description flattens an array of arrays into a single array.\n *\n * @param {Array} array : array to flatten.\n *\n * @returns {Array} flattened array.\n */\nconst flatten = (array) => {\n  if (!(array instanceof Array)) return array;\n  return array.reduce((a, b) => {\n    if (b instanceof Array) a.push.apply(a, flatten(b)); // eslint-disable-line prefer-spread\n    else if (!b) a.push(null);\n    else a.push(b);\n    return a;\n  }, []);\n};\n\nexport default flatten;\n","import { flatten } from '../helpers';\n/**\n * @class ArrayMatrix\n * @description An n-level data object that creates an array\n * matrix from JavaScript Objects based on orders provided.\n *\n * @requires flatten\n *\n * @exports ArrayMatrix\n */\nconst ArrayMatrix = function ArrayMatrix() {\n  /**\n   * @var props\n   * @description array matrix properties\n   * @access private\n   */\n  const props = {\n    dataset: null,\n    order: 0,\n    orders: [],\n  };\n\n  /**\n   * @var axes\n   * @description Stores the axes of the n-order matrix, and\n   * corresponding index for String valued index labels.\n   * @access private\n   *\n   * NOTE: axes is the plural of axis.\n   */\n  const axes = {};\n\n  /**\n   * @var matrix\n   * @description n-order matrix for storing the data set.\n   * @access private\n   */\n  const matrix = [];\n\n  /**\n   * @constructor\n   * @param {Object}\n   * @prop {Array} data : data set to map and store\n   * @prop {Array} orders : names of the orders making up the array matrix\n   */\n  function constructor({ data, orders }) {\n    /*\n      Store properties in the array matrix.\n    */\n    props.order = orders.length;\n    props.orders = orders;\n    props.dataset = data;\n\n    /*\n      For each order, create a key-value pair of\n      the order's name and an empty array in the\n      indices.\n    */\n    (() => {\n      let o = orders.length;\n      while (o--) { // eslint-disable-line no-plusplus\n        axes[orders[o]] = {};\n      }\n    })();\n\n    /*\n      Loop through each item in your dataset,\n      dive into the matrix, and place the item\n      at the correct vertices.\n    */\n    data.forEach((item) => {\n      let pointer = 0;\n      let plane = matrix;\n\n      while (pointer < props.order) {\n        const order = orders[pointer];\n        const index = getAxisPoint(order, item[order], plane); // eslint-disable-line\n        plane = plane[index];\n\n        pointer += 1;\n      }\n\n      plane.push(item);\n    });\n\n    return this;\n  }\n\n  /**\n   * @function getAxisPoint\n   * @description Checks to see if a point exists on the\n   * given axis.\n   *\n   * If it does not exist, it creates the point on the axis and and returns\n   * the index of the new point. The new axis/point assigned\n   * is based off the length of the existing axis's keys to ensure\n   * it is always forced to the very last index in the list.\n   *\n   * If it does exist, it returns the index of the existing point.\n   * @access private\n   *\n   * @param {String} axis : name of the axis\n   * @param {String} point : name for a point on the axis\n   * @param {Array} plane : dimension or plane of the array matrix\n   *\n   * @returns {Integer} index of string label\n   */\n  function getAxisPoint(axis, point, plane) {\n    const i = axes[axis];\n\n    if (typeof i[point] !== 'number') {\n      i[point] = Object.keys(i).length;\n    }\n\n    if (!(plane[i[point]] instanceof Array)) {\n      plane[i[point]] = []; // eslint-disable-line no-param-reassign\n    }\n\n    return i[point];\n  }\n\n  /**\n   * @function getTuple\n   * @description gets the tuple from named points on the axes.\n   * @access private\n   *\n   * @param {Object} points - key value pair of axis/point to get index for.\n   *\n   * @returns {Array} array equivalent of tuple with null as missing point values.\n   */\n  function getTuple(points) {\n    const keys = Object.keys(points);\n    const tuple = new Array(props.order).fill(null);\n\n    for (let i = 0, l = keys.length; i < l; i++) { // eslint-disable-line no-plusplus\n      const key = keys[i];\n      const mIndex = props.orders.indexOf(key);\n\n      if (mIndex === -1) {\n        throw new Error(`Tuple Error: Axis ${key} not found in available axes: ${props.orders.join(', ')}.`);\n      }\n\n      if (typeof points[key] === 'string') {\n        tuple[mIndex] = axes[key][points[key]];\n        if (typeof tuple[mIndex] === 'undefined') {\n          throw new Error(`Tuple Error: Point ${[points[key]]} not found in axis ${key} points: ${Object.keys(axes[key]).join(', ')}`);\n        }\n        continue; // eslint-disable-line no-continue\n      }\n\n      if (typeof points[key] === 'number') {\n        tuple[mIndex] = points[key];\n        continue; // eslint-disable-line no-continue\n      }\n\n      throw new Error(`Tuple Error: ${points[key]} for axis ${key} is not a valid string or integer.`);\n    }\n\n    return tuple;\n  }\n\n  /**\n   * @function deadReckon\n   * @description recursive function that dives into the array matrix\n   * and returns an element or dimension from a set of points.\n   * @access private\n   *\n   * @param {Array} plane : dimension or plane to start.\n   * @param {Array} indices : list of indices to traverse.\n   *\n   * @returns {Any} the node at the end of the traversal\n   */\n  function deadReckon(plane, indices) {\n    if (!indices || !indices.length) return plane;\n\n    // If we are missing an entire dimension or plane, return\n    // empty set;\n    if (!plane) return [];\n\n    return deadReckon(plane[indices.shift()], indices);\n  }\n\n  /**\n   * @function getAxes\n   * @description returns all axes and each axis' points\n   * @access public\n   *\n   * @returns {Object} axes' names with arrays of points\n   */\n  this.getAxes = function getAxes() {\n    return Object.keys(axes).reduce((accumulator, current) =>\n      Object.assign({}, accumulator, { [current]: Object.keys(axes[current]) })\n    , {});\n  };\n\n  /**\n   * @function getAxisPoints\n   * @description returns all points for a given axis.\n   * @access public\n   *\n   * @param {String} axis : name of axis.\n   *\n   * @returns {Array} Array of all an axis's named points.\n   */\n  this.getAxisPoints = function getAxisPoints(axis) {\n    if (!axes[axis]) return null;\n\n    return Object.keys(axes[axis]);\n  };\n\n  /**\n   * @function getDimension\n   * @description gets a dimension of the matrix array based on\n   * named points provided.\n   *\n   * The dimension is the plane of values existing by connecting\n   * n vertices, where n is 1 less than the total number of orders.\n   * @access public\n   *\n   * @param {Object} points : key-value pairs of axis and named points on the axis.\n   *\n   * @returns {Array} array of entries in the plane.\n   */\n  this.getDimension = function getDimension(points) {\n    if (!points || typeof points !== 'object') {\n      throw new Error('Dimension Error: Malformed points argument.');\n    }\n\n    const keys = Object.keys(points);\n\n    if (keys.length !== props.order - 1) {\n      throw new Error(`Dimension Error: ${keys.length} points provided for ${props.order} order matrix array. The number of points must be equal to n - 1, where n is the order or rank of the matrix array.`);\n    }\n\n    const coords = getTuple(points);\n\n    const variableIndex = coords.indexOf(null);\n\n    const entries = (() => {\n      if (variableIndex === 0) {\n        coords.splice(0, 1);\n\n        return matrix.map(aIndex => deadReckon(aIndex, [].concat(coords)));\n      }\n\n      return deadReckon(matrix, coords.slice(0, variableIndex))\n              .map(array => deadReckon(array, coords.slice(variableIndex + 1)));\n    })();\n\n    return flatten(entries);\n  };\n\n  /**\n   * @function getEntry\n   * @description returns the entry in the matrix array at the points provided.\n   * @access public\n   *\n   * @param {Object} points : key-value pairs of named points on axes.\n   *\n   * @returns {Object} entry at the set of points.\n   */\n  this.getEntry = function getEntry(points) {\n    const keys = Object.keys(points);\n\n    if (keys.length !== props.order) {\n      throw new Error(`Entry Error: ${keys.length} points provided for ${props.order} order matrix array. The number of points must be equal to n, where n is the order or rank of the matrix array.`);\n    }\n\n    const coords = getTuple(points);\n\n    let depth = 0;\n    let pointer = matrix;\n    while (depth < coords.length) {\n      if (pointer[coords[depth]]) {\n        pointer = pointer[coords[depth]];\n        depth += 1;\n        continue; // eslint-disable-line no-continue\n      }\n\n      return null;\n    }\n\n    return pointer[0];\n  };\n\n  /**\n   * @function debug\n   * @description returns the array matrix's data\n   * @access public\n   */\n  this.debug = function debug() {\n    return {\n      matrix,\n      axes,\n      props,\n    };\n  };\n\n  return constructor.apply(this, arguments); // eslint-disable-line prefer-rest-params\n};\n\nexport default ArrayMatrix;\n"],"names":["flatten","array","Array","reduce","a","b","push","apply","ArrayMatrix","props","axes","matrix","getAxisPoint","axis","point","plane","i","Object","keys","length","getTuple","points","tuple","order","fill","l","key","mIndex","orders","indexOf","Error","join","deadReckon","indices","shift","getAxes","accumulator","current","babelHelpers.extends","getAxisPoints","getDimension","coords","variableIndex","entries","splice","map","aIndex","concat","slice","getEntry","depth","pointer","debug","data","dataset","o","forEach","item","this","arguments"],"mappings":"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"}