{"version":3,"file":"main.es.js","sources":["../src/helpers/flatten/flatten.js","../src/Tensor/Tensor.js"],"sourcesContent":["/**\n * @function flatten\n * @description flattens an array of arrays into a single array.\n *\n * @param {Array} array : array to flatten.\n *\n * @returns {Array} flattened array.\n */\nconst flatten = (array) => {\n  if (!(array instanceof Array)) return array;\n  return array.reduce((a, b) => {\n    if (b instanceof Array) a.push.apply(a, flatten(b)); // eslint-disable-line prefer-spread\n    else if (!b) a.push(null);\n    else a.push(b);\n    return a;\n  }, []);\n};\n\nexport default flatten;\n","import { flatten } from '../helpers';\n/**\n * @class Tensor\n * @description Tensor manager n-layer datasets\n *\n * @requires flatten\n *\n * @exports Tensor\n */\nconst Tensor = function Tensor() {\n  /**\n   * @var props\n   * @description tensor properties\n   * @access private\n   */\n  const props = {\n    order: 0,\n    orders: [],\n  };\n\n  /**\n   * @var indices\n   * @description Stores the indices of the n-order matrix, and\n   * corresponding index for String valued index labels.\n   * @access private\n   */\n  const indices = {};\n\n  /**\n   * @var matrix\n   * @description n-order matrix for storing the data set.\n   * @access private\n   */\n  const matrix = [];\n\n  /**\n   * @constructor\n   * @param {Object}\n   * @prop {Array} data : data set to map and store\n   * @prop {Array} mutators : any mutations to execute against the data set\n   * @prop {Array} orders : names of the orders making up the tensor\n   */\n  function constructor({ data, orders }) {\n    /*\n      Store properties in the tensor object.\n    */\n    props.order = orders.length;\n    props.orders = orders;\n\n    /*\n      For each order, create a key-value pair of\n      the order's name and an empty array in the\n      indices.\n    */\n    (() => {\n      let o = orders.length;\n      while (o--) { // eslint-disable-line no-plusplus\n        indices[orders[o]] = {};\n      }\n    })();\n\n    /*\n      Loop through each item in your dataset,\n      dive into the matrix, and place the item\n      at the correct vertices.\n    */\n    data.forEach((item) => {\n      let pointer = 0;\n      let array = matrix;\n\n      while (pointer < props.order) {\n        const order = orders[pointer];\n        const index = getIndex(order, item[order], array); // eslint-disable-line\n        array = array[index];\n\n        pointer += 1;\n      }\n\n      array.push(item);\n    });\n\n    return this;\n  }\n\n  /**\n   * @function getIndex\n   * @description Checks to see if a value exists in the\n   * indices.\n   *\n   * If it does not exist, it creates the value and and returns\n   * the index of the new value. The new index/value assigned\n   * is based off the length of the existing index's keys to ensure\n   * it is always forced to the very last index in the list.\n   *\n   * If it does exist, it returns the index of the existing value.\n   * @access private\n   *\n   * @param {String} index : label of the index\n   * @param {String} value : data item's value for the index\n   * @param {Array} array : dimensional array of matrix\n   *\n   * @returns {Integer} index of string label\n   */\n  function getIndex(index, value, array) {\n    const i = indices[index];\n\n    if (typeof i[value] !== 'number') {\n      i[value] = Object.keys(i).length;\n    }\n\n    if (!(array[i[value]] instanceof Array)) {\n      array[i[value]] = []; // eslint-disable-line no-param-reassign\n    }\n\n    return i[value];\n  }\n\n  /**\n   * @function getVertices\n   * @description gets the vertices from string values for a\n   * query.\n   * @access private\n   *\n   * @param {Array} keys - list of query keys\n   * @param {Object} vertices - key value pair of index/value to get vertices for.\n   *\n   * @returns {Array} vertices with null as missing vertex values.\n   */\n  function getVertices(keys, vertices) {\n    const vector = new Array(props.order).fill(null);\n    for (let i = 0, l = keys.length; i < l; i++) { // eslint-disable-line no-plusplus\n      const key = keys[i];\n      const mIndex = props.orders.indexOf(key);\n\n      if (mIndex === -1) {\n        throw new Error(`Vector Error: Index ${key} not found in available indices: ${props.orders.join(', ')}.`);\n      }\n\n      if (typeof vertices[key] === 'string') {\n        vector[mIndex] = indices[key][vertices[key]];\n        if (typeof vector[mIndex] === 'undefined') {\n          throw new Error(`Vector Error: Label ${[vertices[key]]} not found in index ${key} labels: ${Object.keys(indices[key]).join(', ')}`);\n        }\n        continue; // eslint-disable-line no-continue\n      }\n\n      if (typeof vertices[key] === 'number') {\n        vector[mIndex] = vertices[key];\n        continue; // eslint-disable-line no-continue\n      }\n\n      throw new Error(`Vector Error: Value ${vertices[key]} for index ${key} is not a valid string or integer.`);\n    }\n\n    return vector;\n  }\n\n  /**\n   * @function diveMatrix\n   * @description recursive function that dives deep into\n   * a matrix a returns data/dimension from a set of vertices.\n   * @access private\n   *\n   * @param {Array} array : dimension of the tensor.\n   * @param {Array} idx : list of vertices to traverse.\n   *\n   * @returns {Any} the node at the end of the traversal\n   */\n  function diveMatrix(array, idx) {\n    if (!idx || !idx.length) return array;\n\n    return diveMatrix(array[idx.shift()], idx);\n  }\n\n  /**\n   * @function getIndices\n   * @description returns all indices and labels\n   * @access public\n   *\n   * @returns {Object} indices keys with arrays of matrix labels\n   */\n  this.getIndices = function getIndices() {\n    const axes = {};\n\n    Object.keys(indices).forEach((index) => {\n      axes[index] = Object.keys(indices[index]);\n    });\n\n    return axes;\n  };\n\n  /**\n   * @function getIndexLabels\n   * @description returns all labels for a given index.\n   * @access public\n   *\n   * @param {String} index : index for labels to return.\n   *\n   * @returns {Array} Array of all an index's labels.\n   */\n  this.getIndexLabels = function getIndexLabels(index) {\n    if (!indices[index]) return null;\n\n    return Object.keys(indices[index]);\n  };\n\n  /**\n   * @function getVector\n   * @description gets a vector (slice) of the matrix based on\n   * vertices provided.\n   *\n   * The slice is the plane of values existing by connecting\n   * n vertices, where n is 1 less than the total number of orders.\n   * @access public\n   *\n   * @param {Object} vertices : key-value pairs of indices and values/index\n   *\n   * @returns {Array} array of values in the plane.\n   */\n  this.getVector = function getVector(vertices) {\n    if (!vertices || typeof vertices !== 'object') {\n      throw new Error('Vector Error: Malformed vertices provided.');\n    }\n\n    const keys = Object.keys(vertices);\n\n    if (keys.length !== props.order - 1) {\n      throw new Error(`Vector Error: ${keys.length} vertices provided for ${props.order} order tensor. The number of vertices must be equal to n - 1, where n is the order of the tensor.`);\n    }\n\n    const coords = getVertices(keys, vertices);\n\n    const variableIndex = coords.indexOf(null);\n\n    const scalars = (() => {\n      if (variableIndex === 0) {\n        coords.splice(0, 1);\n\n        return matrix.map(aIndex => diveMatrix(aIndex, [].concat(coords)));\n      }\n\n      return diveMatrix(matrix, coords.slice(0, variableIndex))\n              .map(array => diveMatrix(array, coords.slice(variableIndex + 1)));\n    })();\n\n    return flatten(scalars);\n  };\n\n  /**\n   * @function getScalar\n   * @description returns a value at a given set of vertices\n   * @access public\n   *\n   * @param {Object} vertices : key-value pairs of indices and values/index\n   *\n   * @returns {Any} value at the set of vertices.\n   */\n  this.getScalar = function getScalar(vertices) {\n    const keys = Object.keys(vertices);\n\n    if (keys.length !== props.order) {\n      throw new Error(`Scalar Error: ${keys.length} vertices provided for ${props.order} order tensor. The number of vertices must be equal to n, where n is the order of the tensor.`);\n    }\n\n    const coords = getVertices(keys, vertices);\n\n    let pointer = 0;\n    let array = matrix;\n    while (pointer < coords.length) {\n      if (array[coords[pointer]]) {\n        array = array[coords[pointer]];\n        pointer += 1;\n        continue; // eslint-disable-line no-continue\n      }\n\n      return null;\n    }\n\n    return array[0];\n  };\n\n  /**\n   * @function debug\n   * @description returns the tensors data\n   * @access public\n   */\n  this.debug = function debug() {\n    return {\n      matrix,\n      indices,\n      props,\n    };\n  };\n\n  return constructor.apply(this, arguments); // eslint-disable-line prefer-rest-params\n};\n\nexport default Tensor;\n"],"names":["flatten","array","Array","reduce","a","b","push","apply","Tensor","props","indices","matrix","getIndex","index","value","i","Object","keys","length","getVertices","vertices","vector","order","fill","l","key","mIndex","orders","indexOf","Error","join","diveMatrix","idx","shift","getIndices","axes","forEach","getIndexLabels","getVector","coords","variableIndex","scalars","splice","map","aIndex","concat","slice","getScalar","pointer","debug","data","o","item","this","arguments"],"mappings":"AAQA,IAAMA,UAAU,SAAVA,EAAWC,UACTA,aAAiBC,MAChBD,EAAME,OAAO,SAACC,EAAGC,UAClBA,aAAaH,MAAOE,EAAEE,KAAKC,MAAMH,EAAGJ,EAAQK,IACtCA,EACLD,EAAEE,KAAKD,GADCD,EAAEE,KAAK,MAEbF,OAL6BH,qNCAlCO,SAAS,eAMPC,SACG,aAUHC,KAOAC,cAsEGC,EAASC,EAAOC,EAAOb,OACxBc,EAAIL,EAAQG,SAEM,iBAAbE,EAAED,OACTA,GAASE,OAAOC,KAAKF,GAAGG,QAGtBjB,EAAMc,EAAED,cAAmBZ,UACzBa,EAAED,QAGHC,EAAED,YAcFK,EAAYF,EAAMG,WACnBC,EAAS,IAAInB,MAAMO,EAAMa,OAAOC,KAAK,MAClCR,EAAI,EAAGS,EAAIP,EAAKC,OAAQH,EAAIS,EAAGT,IAAK,KACrCU,EAAMR,EAAKF,GACXW,EAASjB,EAAMkB,OAAOC,QAAQH,OAEpB,IAAZC,QACI,IAAIG,6BAA6BJ,sCAAuChB,EAAMkB,OAAOG,KAAK,cAGrE,iBAAlBV,EAASK,OAQS,iBAAlBL,EAASK,SAKd,IAAII,6BAA6BT,EAASK,iBAAkBA,0CAJzDC,GAAUN,EAASK,aARnBC,GAAUhB,EAAQe,GAAKL,EAASK,SACT,IAAnBJ,EAAOK,SACV,IAAIG,8BAA8BT,EAASK,2BAA4BA,cAAeT,OAAOC,KAAKP,EAAQe,IAAMK,KAAK,cAa1HT,WAcAU,EAAW9B,EAAO+B,UACpBA,GAAQA,EAAId,OAEVa,EAAW9B,EAAM+B,EAAIC,SAAUD,GAFN/B,cAY7BiC,WAAa,eACVC,mBAEClB,KAAKP,GAAS0B,QAAQ,SAACvB,KACvBA,GAASG,OAAOC,KAAKP,EAAQG,MAG7BsB,QAYJE,eAAiB,SAAwBxB,UACvCH,EAAQG,GAENG,OAAOC,KAAKP,EAAQG,IAFC,WAkBzByB,UAAY,SAAmBlB,OAC7BA,GAAgC,qBAAbA,sBAAAA,UAChB,IAAIS,MAAM,kDAGZZ,EAAOD,OAAOC,KAAKG,MAErBH,EAAKC,SAAWT,EAAMa,MAAQ,QAC1B,IAAIO,uBAAuBZ,EAAKC,iCAAgCT,EAAMa,+GAGxEiB,EAASpB,EAAYF,EAAMG,GAE3BoB,EAAgBD,EAAOX,QAAQ,MAE/Ba,EACkB,IAAlBD,KACKE,OAAO,EAAG,GAEV/B,EAAOgC,IAAI,mBAAUZ,EAAWa,KAAWC,OAAON,OAGpDR,EAAWpB,EAAQ4B,EAAOO,MAAM,EAAGN,IACjCG,IAAI,mBAASZ,EAAW9B,EAAOsC,EAAOO,MAAMN,EAAgB,aAGhExC,UAAQyC,SAYZM,UAAY,SAAmB3B,OAC5BH,EAAOD,OAAOC,KAAKG,MAErBH,EAAKC,SAAWT,EAAMa,YAClB,IAAIO,uBAAuBZ,EAAKC,iCAAgCT,EAAMa,+GAGxEiB,EAASpB,EAAYF,EAAMG,GAE7B4B,EAAU,EACV/C,EAAQU,EACLqC,EAAUT,EAAOrB,QAAQ,KAC1BjB,EAAMsC,EAAOS,WAMV,OALG/C,EAAMsC,EAAOS,OACV,SAOR/C,EAAM,SAQVgD,MAAQ,+DApPUC,IAAAA,KAAMvB,IAAAA,gBAIrBL,MAAQK,EAAOT,SACfS,OAASA,qBAQTwB,EAAIxB,EAAOT,OACRiC,OACGxB,EAAOwB,YASdf,QAAQ,SAACgB,WACRJ,EAAU,EACV/C,EAAQU,EAELqC,EAAUvC,EAAMa,OAAO,KACtBA,EAAQK,EAAOqB,KAEb/C,EADMW,EAASU,EAAO8B,EAAK9B,GAAQrB,OAGhC,IAGPK,KAAK8C,KAGNC,MAqNU9C,MAAM8C,KAAMC"}